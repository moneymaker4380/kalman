Index: src/strategy.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import numpy as np\nimport pandas as pd\nimport backtrader as bt\nimport scipy.odr as odr\nfrom datetime import datetime\nimport csv\nfrom log_return import LogReturn\nfrom coint import Coint\nfrom kalman import Kalman\nfrom get_data import GetData\n\nclass Strategy(bt.Strategy):\n\n    def log(self, txt, dt=None):\n        ''' Logging function fot this strategy'''\n        dt = dt or self.datas[0].datetime.date(0)\n        print('%s, %s' % (dt.isoformat(), txt))\n\n    # def notify_order(self, order):\n    #     if order.status in [order.Submitted, order.Accepted]:\n    #         # Buy/Sell order submitted/accepted to/by broker - Nothing to do\n    #         return\n    #\n    #     # Check if an order has been completed\n    #     # Attention: broker could reject order if not enough cash\n    #     if order.status in [order.Completed]:\n    #         if order.isbuy():\n    #             self.log('BUY EXECUTED, %.2f' % order.executed.price)\n    #         elif order.issell():\n    #             self.log('SELL EXECUTED, %.2f' % order.executed.price)\n    #\n    #         self.bar_executed = len(self)\n    #\n    #     elif order.status in [order.Canceled, order.Margin, order.Rejected]:\n    #         self.log('Order Canceled/Margin/Rejected')\n\n\n    def __init__(self):\n        self.adf_threshold = -2.0\n        self.pairs_num = 20\n        self.init_days = 2520\n        self.last_rebel = 0\n        self.rebal_period = 30\n        self.min_asr = 1\n        self.pair_kalman = {}\n        self.pair_betas = {}\n        self.dataclose = self.datas[0].close\n        self.stat = open('position.csv', mode='w')\n        self.stat.write(','.join(['']+[d._name for d in self.datas]+['\\n']))\n        self.initBool = False\n        self.inds = dict()\n        self.feed_dict = dict()\n        self.coint_dict = dict()\n        self.powerStat = []\n        self.current_pairs = [] #Assume pairs named by the stock in the pair\n        for i, d in enumerate(self.datas):\n            self.inds[d] = dict()\n            self.inds[d]['log_return'] = LogReturn(d)\n        pass\n\n    def nextstart(self):\n        # initialize pairs\n        pass\n\n    def next(self):\n        stocks_list = [d._name for d in self.datas][4:]\n        print(len(self))\n        if ((not self.initBool) and (len(self) == self.init_days)):\n            for i, d in enumerate(self.datas):\n                self.feed_dict[d._name] = i\n            self.tarpos = pd.Series(np.zeros(len(self.feed_dict)),index = self.feed_dict.keys())\n            self.pair_ratio = pd.Series(np.zeros(len(self.feed_dict)),index = self.feed_dict.keys())\n            init_pair = []\n            for ticker in stocks_list:\n                coint = Coint(self, self.feed_dict, ticker, ['QUAL','USMV','VLUE','MTUM'], 300, adf_threshold=self.adf_threshold)\n                if abs(coint.sr()) > self.min_asr and coint.t_stat <= self.adf_threshold:\n                    init_pair.append(coint.powerStat())\n                else:\n                    init_pair.append(0)\n            for ticker in np.array(stocks_list)[np.argsort(init_pair)[-self.pairs_num:][::-1]]:\n                self.coint_dict[ticker] = Coint(self,self.feed_dict,ticker,['QUAL','USMV','VLUE','MTUM'],300,adf_threshold=self.adf_threshold)\n            \"\"\"\n            print(coint.beta)\n            print(coint.t_stat, coint.p_lags)\n            kf = Kalman(coint.residuals,-2.0,coint.adf_betas,coint.adf_betas_cov,coint.adf_res_var)\n            print(kf.state_mean)\n            print(np.diag(kf.state_cov))\n            print(kf.tStat())\n            \"\"\"\n            self.initBool = True\n            self.last_rebel = len(self)\n        elif((self.initBool) and (len(self) >= self.init_days)):\n            signals = []\n            if ((len(self.coint_dict.keys()) <= self.pairs_num/2) or (len(self) - self.last_rebel >= self.rebal_period)):\n                new_pair = []\n                curr_pair = list(self.coint_dict.keys())\n                for ticker in stocks_list:\n                    if ticker in curr_pair:\n                        continue\n                    coint = Coint(self, self.feed_dict, ticker, ['QUAL', 'USMV', 'VLUE', 'MTUM'], 300, adf_threshold=self.adf_threshold)\n                    if coint.asr() > self.min_asr and coint.t_stat <= self.adf_threshold:\n                        new_pair.append(coint.powerStat())\n                    else:\n                        new_pair.append(0)\n                for ticker in np.array(stocks_list)[np.argsort(new_pair)[-self.pairs_num:][::-1]]:\n                    if len(self.coint_dict) >= self.pairs_num:\n                        break\n                    if ticker not in list(self.coint_dict.keys()):\n                        self.coint_dict[ticker] = Coint(self, self.feed_dict, ticker, ['QUAL', 'USMV', 'VLUE', 'MTUM'], 300, adf_threshold=self.adf_threshold)\n            # signals = [{'MSFT': 1, 'VTV': -0.5, 'VUG': -0.5}]  # Presented in ratios (stock comes first)\n            self.last_rebel = len(self)\n\n            for ticker in list(self.coint_dict.keys()):\n                y = np.log(self.datas[self.feed_dict[ticker]].close[0]/self.coint_dict[ticker].reference_price[ticker])\n                x = [np.log(self.datas[self.feed_dict[etf]].close[0]/self.coint_dict[ticker].reference_price[etf]) for etf in self.coint_dict[ticker].etfs]\n                self.coint_dict[ticker].update_residual(np.array([x]), y)\n                signal = self.coint_dict[ticker].signal()\n                if len(signal) > 0:\n                    signals.append(signal)\n            if len(signals)!=0:\n                #reset tar pos\n                self.tarpos = pd.Series(np.zeros(len(self.feed_dict)),index = self.feed_dict.keys())\n                self.close_pairs = []\n                for signal in signals:\n                    ##cannot pass as list\n                    if pd.Series(signal.keys())[0] not in self.current_pairs:\n                        self.current_pairs.append(list(signal.keys())[0])\n                        self.pair_ratio.loc[list(signal.keys())[0]] = [signal]\n                    else:\n                        self.current_pairs.remove(list(signal.keys())[0])\n                        self.pair_ratio.loc[list(signal.keys())[0]] = np.nan\n                        self.close_pairs.append(list(signal.keys())[0])\n                for pair in self.current_pairs:\n                    for tick in self.pair_ratio.loc[pair][0]:\n                        self.tarpos.loc[tick] += self.pair_ratio.loc[pair][0][tick]/len(self.current_pairs)\n                        # print(self.datas[self.feed_dict[tick]])\n                #Close position of stocks\n                self.tarpos = self.tarpos.astype('int')\n                if len(self.close_pairs)>0:\n                    for tick in self.close_pairs:\n                        order = self.order_target_percent(self.datas[self.feed_dict[tick]],target=0)\n                        print(order)\n                        #order = self.broker.submit(order)\n                if len(self.current_pairs)>0:\n                    for tick in self.current_pairs:\n                        order = self.order_target_percent(self.datas[self.feed_dict[tick]],target=self.tarpos.loc[tick])\n                        print(order)\n                        #order = self.broker.submit(order)\n                for tick in ['QUAL','USMV','VLUE','MTUM']:\n                    order = self.order_target_percent(self.datas[self.feed_dict[tick]],target=self.tarpos.loc[tick])\n                    print(order)\n                    #if order is not None:\n                        #order = self.broker.submit(order)\n\n            for ticker in list(self.coint_dict.keys()):\n                if self.coint_dict[ticker].eliminate:\n                    self.coint_dict.pop(ticker)\n                \"\"\"\n                for i, d in enumerate(self.datas):\n                    # self.log(f'{d._name} Close, {d.close[0]}')\n                    #self.log(f'{d._name} Position: {self.broker.getposition(d)}')\n                    # self.stat.write(str(self.broker.getposition(d).size)+',')\n                    pos = self.getposition(d).size\n                    if len(self) % (252) == (0):\n                        self.buy(d,size=10000)\n                    elif len(self) % (252) == 126:\n                        self.sell(d,size=10000)\n                \"\"\"\n            self.stat.write('\\n')\n            #print(self.positionsbyname['MSFT'])\n    \n    def close_pos(self,signal):\n        pass\n    \n    def stop(self):\n\n\n\n\n\n            #self.log('LogReturn, %.2f' % self.inds[0])\n\n\n            # if not self.position:  #not in the market\n            #     if next_long > 0:\n            #         self.buy()  #enter long position\n            #     elif next_short < 0:\n            #         self.close()  #close long position\n        pass\n\n# def coint_test(self, stock_df, etf_df):\n#     stockR = np.log(stock_df.div(stock_df[0]))\n#     etfR = np.log(etf_df.div(etf_df[0]))\n#\n#     return betas, n_lags, t_stat,\n\n#\n# ###cointegration\n# from statsmodels.tsa.stattools import coint\n# def find_cointegrated_pairs(data):\n#     n = data.shape[1]\n#     pvalue_matrix = np.ones((n, n))\n#     score_matrix = np.zeros((n, n))\n#     keys = data.keys()\n#     pairs = []\n#     for i in range(n):\n#         for j in range(i+1, n):\n#             result = coint(data[keys[i]], data[keys[j]])\n#             score_matrix[i,j] = result[0]\n#             pvalue_matrix[i, j] = result[1]\n#             if result[1] < 0.05:\n#                 pairs.append((keys[i], keys[j]))\n#     return score_matrix, pvalue_matrix, pairs #return p=lag\n#             pvalue_matrix[i, j] = result[1]\n#             if result[1] < 0.05:\n#                 pairs.append((keys[i], keys[j]))\n#     return pvalue_matrix, pairs #return p=lag, statistics\n#\n#\n# #TLS\n# def odr_line(z, x):\n#     #Define a function to fit the data with.\n#     \"\"\"The line of best fit.\"\"\"\n#     m, c = z\n#     y = m*x + c\n#     return y\n# linear = odr.Model(odr_line)\n# mydata = RealData(x, y)\n# myodr = odr.ODR(mydata, linear, beta0=[0]) #can be beta0=[0., 1.]\n# output = myodr.run()\n#\n#\n# ###ADF\n# #set maxlag=0?\n#\n#\n# def z_score(series):\n#  return ((series - np.mean(series)) / np.std(series))\n#\n#\n# ###cerebro\n# cerebro = bt.Cerebro()\n# data = bt.feeds.PandasData(dataname=df0,\n#                            fromdate = datetime(2006, 1, 2),\n#                            todate = datetime(2020, 12, 31)\n#                           )\n# cerebro.adddata(data)\n# cerebro.addstrategy(TestStrategy)\n# cerebro.broker.setcommission(commission=0.0)\n# cerebro.broker.set_cash(cash=10000000)\n# print('Starting Portfolio Value: %.2f' % cerebro1.broker.getvalue())\n# import backtrader.analyzers as btanalyzers\n# cerebro.addanalyzer(bt.analyzers.Calmar, _name = 'Calmar')\n# cerebro.addanalyzer(bt.analyzers.SharpeRatio, _name = 'SharpeRatio')\n# cerebro.addanalyzer(bt.analyzers.DrawDown, _name='DD')\n# cerebro.run()\n# print('Final Portfolio Value: %.2f' % cerebro1.broker.getvalue())\n# print('CR:', strat.analyzers.Calmar.get_analysis())\n# print('SR:', strat.analyzers.SharpeRatio.get_analysis())\n# print('DD:', strat.analyzers.DW.get_analysis())\n# cerebro.plot()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/strategy.py	(revision c1e3653a780705c6b44c2f6c73741916afaf4509)
+++ src/strategy.py	(date 1618839886911)
@@ -48,6 +48,7 @@
         self.stat = open('position.csv', mode='w')
         self.stat.write(','.join(['']+[d._name for d in self.datas]+['\n']))
         self.initBool = False
+        self.stopFindPair = False
         self.inds = dict()
         self.feed_dict = dict()
         self.coint_dict = dict()
@@ -70,15 +71,20 @@
                 self.feed_dict[d._name] = i
             self.tarpos = pd.Series(np.zeros(len(self.feed_dict)),index = self.feed_dict.keys())
             self.pair_ratio = pd.Series(np.zeros(len(self.feed_dict)),index = self.feed_dict.keys())
-            init_pair = []
+            init_pair = dict()
+            power_stat = []
             for ticker in stocks_list:
                 coint = Coint(self, self.feed_dict, ticker, ['QUAL','USMV','VLUE','MTUM'], 300, adf_threshold=self.adf_threshold)
                 if abs(coint.sr()) > self.min_asr and coint.t_stat <= self.adf_threshold:
-                    init_pair.append(coint.powerStat())
+                    init_pair[ticker] = coint
+                    power_stat.append(coint.powerStat())
                 else:
-                    init_pair.append(0)
-            for ticker in np.array(stocks_list)[np.argsort(init_pair)[-self.pairs_num:][::-1]]:
-                self.coint_dict[ticker] = Coint(self,self.feed_dict,ticker,['QUAL','USMV','VLUE','MTUM'],300,adf_threshold=self.adf_threshold)
+                    power_stat.append(-1)
+            power_stat = np.array(power_stat)
+            accepted = np.argwhere(power_stat > -1)
+            accepted_order = accepted[np.argsort[power_stat[accepted]][::-1]]
+            for ticker in power_stat[accepted_order[-min(self.pairs_num:]]:
+                self.coint_dict[ticker] = init_pair[ticker]
             """
             print(coint.beta)
             print(coint.t_stat, coint.p_lags)
@@ -91,17 +97,18 @@
             self.last_rebel = len(self)
         elif((self.initBool) and (len(self) >= self.init_days)):
             signals = []
-            if ((len(self.coint_dict.keys()) <= self.pairs_num/2) or (len(self) - self.last_rebel >= self.rebal_period)):
-                new_pair = []
+            if ((not self.stopFindPair and (len(self.coint_dict.keys()) <= self.pairs_num/2)) or (len(self) - self.last_rebel >= self.rebal_period)):
+                new_pair = dict()
+                power_stat = []
                 curr_pair = list(self.coint_dict.keys())
                 for ticker in stocks_list:
                     if ticker in curr_pair:
+                        power_stat.append(-1)
                         continue
                     coint = Coint(self, self.feed_dict, ticker, ['QUAL', 'USMV', 'VLUE', 'MTUM'], 300, adf_threshold=self.adf_threshold)
                     if coint.asr() > self.min_asr and coint.t_stat <= self.adf_threshold:
-                        new_pair.append(coint.powerStat())
-                    else:
-                        new_pair.append(0)
+
+                        power_stat.append(coint.powerStat())
                 for ticker in np.array(stocks_list)[np.argsort(new_pair)[-self.pairs_num:][::-1]]:
                     if len(self.coint_dict) >= self.pairs_num:
                         break
